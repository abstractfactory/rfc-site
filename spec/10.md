---
layout: spec
name: http://rfc.abstractfactory.io/spec/10
title: Open Metadata Specification
tags: publishing
number: 10
related: RFC1, RFC12, RFC13, RFC14, RFC15, RFC16, RFC16, RFC17, RFC18, RFC19, RFC20, RFC24, RFC35, RFC41, RFC46
modified: 2014-04-21 14:07:35+0100
state: draft
link: https://github.com/abstractfactory/rfc/blob/master/spec/spec10.md
editor: Marcus Ottosson <marcus@abstractfactory.io>
summary: This document defines what it means to be Open Metadata.
---

# Open Metadata Specification

This document defines what it means to be Open Metadata.

* Name: http://rfc.abstractfactory.io/spec/10
* Editor: Marcus Ottosson <marcus@abstractfactory.io>
* Related: [RFC1](http://rfc.abstractfactory.io/spec/1), [RFC12](http://rfc.abstractfactory.io/spec/12), [RFC13](http://rfc.abstractfactory.io/spec/13), [RFC14](http://rfc.abstractfactory.io/spec/14), [RFC15](http://rfc.abstractfactory.io/spec/15), [RFC16](http://rfc.abstractfactory.io/spec/16), [RFC16](http://rfc.abstractfactory.io/spec/16), [RFC17](http://rfc.abstractfactory.io/spec/17), [RFC18](http://rfc.abstractfactory.io/spec/18), [RFC19](http://rfc.abstractfactory.io/spec/19), [RFC20](http://rfc.abstractfactory.io/spec/20), [RFC24](http://rfc.abstractfactory.io/spec/24), [RFC35](http://rfc.abstractfactory.io/spec/35), [RFC41](http://rfc.abstractfactory.io/spec/41), [RFC46](http://rfc.abstractfactory.io/spec/46)
* Tags: publishing
* State: draft

Copyright and Language can be found in [RFC1](http://rfc.abstractfactory.io/spec/1)

# Change Process

This document is governed by the [Consensus-Oriented Specification System](http://www.digistan.org/spec:1/COSS) (COSS).

# History

Open Metadata was first initiated in 2013 to facilitate the development of [Pipi][] and as a response to the ever-more complex nature of metadata for common use.

#### Definition

* meta -- Pertaining to a level above or beyond
* content -- A collection of data
* data -- A piece of information

In layman's terms; "data about data" - regardless of data-type or traditional use.

#### See also

* [RFC12](http://rfc.abstractfactory.io/spec/12): Cascading
* [RFC13](http://rfc.abstractfactory.io/spec/13): Task Distribution
* [RFC14](http://rfc.abstractfactory.io/spec/14): Temporal Metadata
* [RFC15](http://rfc.abstractfactory.io/spec/15): Meta Metadata
* [RFC16](http://rfc.abstractfactory.io/spec/16): Blob
* [RFC17](http://rfc.abstractfactory.io/spec/17): Cross-referencing
* [RFC18](http://rfc.abstractfactory.io/spec/18): Types
* [RFC19](http://rfc.abstractfactory.io/spec/19): Storage Agnostic
* [RFC20](http://rfc.abstractfactory.io/spec/20): Referencing
* [RFC35](http://rfc.abstractfactory.io/spec/35): Garbage Collection
* [RFC41](http://rfc.abstractfactory.io/spec/41): Temporal Resolution
* [RFC46](http://rfc.abstractfactory.io/spec/46): Temporal Resolution

#### References

* [Notes on consistent metacontent][]
* [Introduction to Augment pt. 1][]
* ["Everything is a file"][]
* [Variable][]

# Goal

Introduce a mechanism with which to associate metadata with a location in such a way that it becomes as transparent to the end-user as handling files.

Metadata is crucial and a basic component not only of computers and the systems we build, but to our psyche. Knowledge is knowledge, but so is our knowledge about this knowledge and therein lies the keyword; *about*. Meta-knowledge. Knowledge is information is `data`.

Open Metadata MUST allow for any `data` to contain metadata, including metadata itself, and it must to so in a manner that doesn't affect the original `data` (See [RFC24](http://rfc.abstractfactory.io/spec/24) on "Sidecar files") and finally this data MUST NOT be bound by any particular representation; meaning it may be stored in any format capable of being represented on a file-system.

# Zen of Open Metadata

* Change is common
* Usability is more important than features
* Control is more important than performance
* Encapsulation is more important than disk space

# Architecture

Open Metadata defines two types; `location` and `entry`. Location is a reference to a folder on disk.

```python
location = '/home/marcus'
```

Entry represent and entry into a `database`; `database` is the term used for any data-store - including but not limited to relational databases, file-systems and in-memory data-structures.

An `Entry` MUST be able to contain one or more `Entry` objects.

An `Entry` that reference non-supported data-types are referred to as a `blob`, such as `jpeg` or `mp3` and are treated like incomprehensible blobs of data; usually either copied or hard-linked into a metadata repository.

Read more about Blobs in [RFC16](http://rfc.abstractfactory.io/spec/16)

### Data-types

A data-format is the physical layout of one's and zero's within the one-dimensional array of bytes that make up a file on a file-system, e.g. `jpeg`, `zip`. A data-type however is their interface towards the programmer - their object-type, if you will - and determines what tools are available; both textually but also graphically.

All data-types native to Open Metadata MUST serialise outgoing data into JSON-compatible data.

Here are all the supported types

**Generic**

* `bool`
* `int`
* `float`
* `string`
* `text`
* `date`
* `color`
* `flag`
* `arg`
* `kwarg`
* `url`
* `path`
* `null`
* `enum`
* `tuple`
* `list`
* `dict`

**Numbers**

* `point`
* `vector`
* `matrix`

**Communication**

* `like`
* `email`
* `following`
* `message`
* `conversation`

`bool`, `int`, `float`, `string` and `date` represent simple files with an added suffix corresponding to their type, such as *myfile.string*. `enum`, `tuple` and `list` however are different from regular groups in that they are *ordered*; meaning they maintain the individual indexes of each member. This is useful when storing data that may be visualised in a UI which needs to display items in a certain order; such as a full address.


```python
# Python example
data = ['31 Quantum Tower',
    'Poland Road',
    'W21X 8SL',
    'London',
    'UK']

location = Location('/home/marcus')
collection = Collection('myaddress.list', parent=location)

collection.value = data
collection.dump()

assert collection.value == data

```

### Default values

Each entry MAY provide a default value.

* `bool` = `False`
* `int` = `0`
* `float` = `0.0`
* `string` = `''`
* `text` = `''`
* `date` = `Current Date`
* `null` = `Empty`


### Late binding

Late binding implies that functionality within an object is determined at run-time. 

In a database, each entry is stored along with a suffix that determine its type; e.g. string, float, bool etc. When assigning any value to a entry, this type is implicitly defined; similar to variables in a dynamically typed programming language such as Python:

```python
# Which data-type does `my_variable` end up with? (spoiler: a boolean)
>>> my_variable.value = 'hello'
>>> my_variable.value = 5
>>> my_variable.value = True
```

This works, because there MUST exist only one (1) suffix per entry within the database.

```python
om.write(path, '/secretOfLife, 'coconut')
om.write(path, '/secretOfLite', 47)
# This overwrites the 'secretOfLite.string' on disk
# with 'secretOfLife.int', just like it would in any programming language
```

The same MAY apply to groups as well.

```python
>>> my_variable.value = 'this will make a entry of type "string"'
>>> my_variable.value = ['this will make a collection', 'of type "list"']
```

#### References

* http://en.wikipedia.org/wiki/Late_binding
* http://en.wikipedia.org/wiki/Dynamic_dispatch

### Data-formats

Native data-formats, such as `txt` or `jpeg` are treated with the minimal knowledge that their corresponding suffix allows, which in most cases are fine; a `jpeg` can only mean a rectangular bit-map with only one possible compression method.

### Location

Refer to an absolute path as *location* so as to facilitate for future expansion into using URI/URL addresses.

It MUST NOT matter to the programmer *where* the metadata is stored and it MUST NOT matter in what format that data resides. With such assumptions, we can assert valid metadata and standard use regardless of it residing on a remote file-system, within a binary file or in-memory within an application. Any content can contain metadata, regardless of what is hosting it.

### 

### Writing to groups

Data MAY be written directly to groups; this becomes the metadata of that collection. In the example above we dump directly to a Group object. The resulting entries are formatted according to the collection's suffix which in this case results in an ordered list.

In other cases, where the collection has no suffix, the data is formatted as-is; meaning Mk2 will determine in which format the data is to be stored based on its object-type within the given programming language and imprint the result into the suffix of the entry.

```python

# Example of auto-determining data-type from suffix-less collection using
collection = Collection('mygroup', parent=location)
collection.value = ['some data']
```

This MAY introduce a possible performance penalty; due to the amount of guess-work that has to be done and so the user SHOULD explicitly specify the data-type for any given collection.

# Syntax

The purpose of Open Metadata remains the same and the syntactical differences are cosmetic-only.

```python
"""Demonstration of the current syntax"""

import os 
import openmetadata as om 

path = os.path.expanduser('~') 
path = os.path.join(path, 'test_folder') 

location = Location(path) 
assert not location.exists 

data = {
    'hello': 'there', 
    'startFrame': 5, 
    'endFrame': 10, 
    'hidden': True
} 

collection = Collection('keyvaluestore.dict', parent=location)
collection.value = data
collection.dump()
  
assert collection.value == data
assert location.value == {collection.name: data}

location.clear()
assert not location.exists
```

### Bracket-notation

Open Metadata MAY support the notion of accessing members via bracket-notation.

```python
>>> location['child']
```

### Use of `dump()`

Coupling reading and writing within the same object sure is a convenience, but also introduces a security risk. I'm not talking about someone hacking your object while you use it, but more of security for you, yourself, while using an object. Having `dump()` so close to overall operation of an object, a misspelling or misuse could potentially lead to removing important information.

An alternative is to introduce a separate method responsible for dump-operations.

```python
>>> location = Location('/home/marcus')
>>> collection = Collection('description.list')
>>> collection.value = ['my', 'ordered', 'list']
>>> dump(collection)
```

It didn't take any more lines of code, yet the implementation of writing is de-coupled from the object with which the contains resides and put into a more global space from where it can be distributed appropriately if need be.

### Benefits of `dump()`

Separating objects and communication has other benefits. One of which lies in the ability to overload `dump()` with logging or networking functionality; such as wrapping up `dump()` in a custom `my_dump()` that does what `dump()` does but more; specific to your situation.

This leaves the object pure and lightweight in situations where many objects need to be used, and keeps the heavy machinery and logic on the outside, where it can more easily be scrutinised.

Another benefit is their interchangeability. `dump()` performs an action, but the action is not necessarily unique and could be replaced by another, without modifying the object, which may have become a dependency in your software already.

# Arbitrary Depth

An important aspect of Mk2 is that of arbitrary depths; i.e. allowing for an unlimited nesting of `entry` within `collection`.

```python
+-- top folder
    +-- group1
        +-- group2
            +--group3
                +-- entry.string
```

## Mixing `entry` objects

Open Metadata MUST support the notion of mixing `entry` objects within a hierarchy.

```python
+-- top folder
    +-- group1
    +-- entry1
```

# Automatic types

Open Metadata MUST support the notion of lazily assigning data to `Entry` objects

```python
>>> location = Location('/home/marcus')

# We'll define a entry, but neglect to give it a suffix.
# The contents of this entry could be anything at this point.
>>> entry = Entry('my_simple_entry', parent=location)

# Assining data of type 'string' will automatically specify 'string' 
# as the data-type of this entry, resulting in a file on disk with
# a suffix of 'string'
>>> entry.value = 'my simple string'

>>> dump(entry)
```

# Esoteric types

In addition to what you would expect from a metadata-storage API, there is one other possibility that may keep you up at night (in a good way).

We'll cover

* `entry.stream`
* `entry.sql`
* `entry.rpc`

### `stream`

```python
+-- folder
|   +-- presentation.stream
```

It's important to remember that a file is nothing more than a logical representation of a sequence of 1s and 0s on a hard-drive. Now, whenever you stream video from YouTube, this concept is still very much in play.

It may not stream to disk, but if it did it would not matter. What matters is the sequence of 1s and 0s and how those are represented to you.

In the example above, there is a entry within a folder with the suffix 'stream'. This indicates that within this file lies instructions for how to connect to a source other than your hard-drive and to provide you with a handle to it; just like you would a regular file.

What do to with this handle however is outside of the scope of this specification and in fact outside the scope of Open Metadata itself.

What Open Metadata provides to you is the possibility of storing such an instruction in arbitrary folders on your hard-drive; it'd then be up to your front-end to interpret and possibly visualise this stream for you.

### `sql`

Any database is ultimately just one or more files on some disk. You could gain access to this file, but it would bear little meaning. What would be more interesting however is to attain a handle into a particular portion of an SQL-based database and manipulate it just like you would a regular Open Metadata entry. Perhaps even store this handle somewhere in your local hard-drive, as metadata to a folder.

```python
>>> location = Location('/some/folder')
>>> location.tree()
# +-- folder
# |   +-- startFrame.sql
```

### `rpc`

How about reading and writing data via a remote procedure call (RPC)? The entry could contain instructions for either and get interpreted by your application.

```python
>>> location = Location('/some/folder')
>>> location.tree()
# +-- folder
# |   +-- startFrame.rpc
```


[Variable]: http://en.wikipedia.org/wiki/Variable_(computer_science)
[Pipi]: http://pipi.io
["Everything is a file"]: http://www.abstractfactory.io/blog/everything-is-a-file/
[Introduction to Augment pt. 1]: http://www.abstractfactory.io/blog/introduction-to-augment-pt-1/
[Notes on consistent metacontent]: http://www.abstractfactory.io/blog/notes-on-consistent-metacontent/